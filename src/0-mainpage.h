/**
 *   @mainpage Layered Graph Heuristics
 * <h3>Programs generated by 'make'</h3>

     - <strong>min_crossings</strong>: implements all the heuristics; has lots of options that
     control which preprocessor/heuristic is run, stopping criteria, etc.
     - <strong>create_random_dag</strong>: creates a connected dag; command-line arguments
     specify the number of nodes, edges, and layers, and the skew factor
     A script for creating a uniform dag is in the scripts directory: it's
     called createDag.
     - <strong>add_edges</strong>: adds a given number of randomly chosen edges to a layered
     dag.


    Copyright (C) 2009, 2011 Matthias Stallmann, Saurabh Gupta.
    Contact: matt_stallmann AT ncsu DOT edu

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License (gnu-public-license.txt) along with this program.

    If not, write to the
     Free Software Foundation, Inc.,
     51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

<h3>Main Heuristics</h3>

Descriptions of the heuristics implemented as part of this project.

   Heuristics are executed using the <strong>min_crossings</strong> program.
   Each heuristic consists of a preprocessing phase (specified using the -p
   option) and an iterative phase (specified using -h).

   Possible <strong>preprocessors</strong> are

    - <strong><em>dfs</em></strong>: Do a depth-first search of the graph and sort each layer by
    preorder number. The start node is a node on the lowest
    level. Adjacent vertices on the next higher layer are explored before
    those on the next lower layer. See dfs.

    - <strong><em>bfs</em></strong>: same as dfs, but a breadth-first search is done (not implemented)

    - <strong><em>mds</em></strong>: (middle degree sort) Identify the node <var>w</var> with highest
      degree, put it in the middle of its layer and sort the rest so that
      larger degree vertices are closer to the middle. Then do an upward and
      a downward sweep of barycenter (see below).

    Possible <strong>main (iterative)</strong> heuristics are as follows. In
    each case the actions that take place during a single <em>pass</em> are
    described. Passes are repeated until there is no improvement in number of
    crossings (default) or a fixed number has occurred (specified by a
    command-line option).
 
    - <strong><em>bary</em></strong>: The barycenter heuristic defined in the literature -- each layer
     is sorted using the average position of the adjacent vertices on the
     layer above/below it (<em>average position</em> sorting). In a single pass, barycenter does an
     <em>upsweep</em>, sorting layers 1 to <var>k</var>-1 based on the layer
     above each, and a <em>downsweep</em>, sorting layers <var>k</var> down
     to 2 based on the layer below each.

    - <strong><em>mod_bary</em></strong>: Choose the layer <em>L</em> whose edges
      contribute the most crossings. Use an average position sort with
      respect to the layer above and the layer below <var>L</var>
      (simulatiously). Then sort layers <var>L</var>-1 and <var>L</var>+1
      with respect to <var>L</var>. Mark <var>L</var> and repeat until all
      layers have been marked. The order in which layers are considered is
      <em>dynamic</em>, i.e., may change as the result of the sorting of a
      previous layer.

    - <strong><em>sifting:</em></strong> Use the sifting heuristic described
        in Matuszewski et al., <em>Using Sifting for k-layer Straightline
        Crossing Minimization.</em>
        To <em>sift</em> a node <var>w</var>, find its optimal position, i.e., keeping all other
        nodes on <var>w</var>'s layer the same determine the position among
        them that minimizes crossings.
        Nodes are sorted by decreasing degree and sifted accordingly (other
        node sequences were proposed but are not implemented here).
        
    - <strong><em>mcn:</em></strong> (maximum crossings node) This is a
        variation on sifting where the next node to be sifted is the one that
        has the maximum number of crossings. This information is updated
        <em>dynamically</em> and nodes are sifted until all have been "marked".
        
    - <strong><em>mce:</em></strong> (maximum crossings edge)
      Another variation on sifting -- here, the heuristic picks an edge
      <var>e = vw</var> that has the maximum number of crossings.
      Both <var>v</var> and <var>w</var> are sifted, but the objective is to
      minimize the number of crossings for <var>e</var>. The chosen position
      in each case is a local rather than global minimum. There are three
      options for ending a pass.
      -# <em>nodes:</em> (default) mark a node when it's an endpoint of a
      chosen edge; stop when all nodes are marked
      -# <em>early:</em> mark a node when it's the endpoint of a chosen edge;
      stop as soon as the next edge under consideration has both endpoints
      marked. 
      -# <em>edges:</em> mark an edge when it is chosen; stop when all edges
      are marked

    - <strong><em>mce_s:</em></strong> (maximum crossings edge with sifting)
    The same as mce except that each iteration does ordinary sifting
    (minimize total crossings) instead of minimizing the crossings for a
    specific edge.

    - <strong><em>mse:</em></strong> (maximum stretch edge) Similar to
    mce. In this case the edge with maximum stretch
    (see <a
    href="ftp://ftp.ncsu.edu/pub/unity/lockers/ftp/csc_anon/tech/2016/TR-2016-6.pdf">technical
    report</a>) is chosen at each iteration and the nodes on layers of the
    endpoints are sorted so as to minimize total stretch.
