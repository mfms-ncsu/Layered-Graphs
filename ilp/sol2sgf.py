#! /usr/bin/env python3

"""
Converts solution of a linear integer program to a graph in .sgf format
This program translates from standard input to standard output.
"""

import sys

from argparse import ArgumentParser
from argparse import RawTextHelpFormatter # to allow newlines in help messages

_graph_name = ""
_comments = []

"""
Simple description for now, may want to add options later
"""
parser = ArgumentParser(formatter_class=RawTextHelpFormatter,
                        description='takes output from cplex_ilp -solution on a file generated by sgf2ilp\n'
                        + ' and converts it to an sgf file with nodes on each layer in the order specified by the solution',
                        epilog='Usage: sol2sgf.py < CPLEX_SOLUTION_FILE > SGF_FILE')

args = parser.parse_args()

"""
 @return a tuple of the form (node_list, edge_list)
 node_list is a list of nodes, each a tuple (id, layer, position)
 edge_list is a list of edges, each a tuple (source, target)  
"""
def read_sol(input):
    global _graph_name
    _graph_name = get_graph_name(input)
    get_run_information(input)
    solution = get_solution(input)
    node_list = []
    edge_list = []
    for line in solution:
        tag = line[0]
        if tag == 'p':
            # a position variable has the form p_i_j, where i is a node id, j
            # is its layer; the value is the position
            node = process_node(line)
            node_list.append(node)
        elif tag == 'e':
            # edges are deduced from dummy variables of the form e_u_v, where uv is an edge
            edge = process_edge(line)
            edge_list.append(edge)
        # otherwise ignored
        
    return node_list, edge_list
    
# retrieves the name of the graph from the file name
def get_graph_name(input):
    global _comments
    for line in input:
        words = line.split()
        if len(words) > 0 and words[0] == "InputFile":
            # drop the .lp from the input file name
            """
            @todo make this more sophisticated (strip out directory)
            """
            return words[1][:-3]
        else:
            _comments.append(line.strip())
    return "unknown_name"

# get information about the cplex run and store it with the comments, stop
# when you get to the Objective value
def get_run_information(input):
    for line in input:
        words = line.split()
        if len(words) > 0 and (
                words[0] == "runtime"
                or words[0] == "TimedOut"
                or words[0] == "ProvedOptimal" ):
            _comments.append(line.strip())
        elif len(words) > 0 and words[0] == "value":
            _comments.append(line.strip())
            return

# @ return a tuple of the form (i, L, P) for a line of the form
# p_i_L P
def process_node(line):
    list = line.replace('_', ' ').split()
    # now the line looks like p i L P
    node_id = list[1]
    layer = list[2]
    # make sure position is an integer (round if it is not)
    position_in_layer = float(list[3])
    if (int(position_in_layer) != position_in_layer):
        position_in_layer = int(position_in_layer + 0.5)
    else:
        position_in_layer = int(position_in_layer)
    return (node_id, layer, position_in_layer)
    
# @return a tuple of the form u, v for a line of the form
# e_u_v 0
def process_edge (line):
    list = line.replace('_', ' ').split()
    u = list[1]
    v = list[2]
    return (u, v)

# @return lines between BeginSolution and EndSolution
def get_solution(input):
    solution = []
    # Skips text before the beginning of the interesting block:
    for line in input:
        if line.strip() == 'BeginSolution':
            break
    # Reads text until the end of the block:
    for line in input:  
        if line.strip() == 'EndSolution':
            break
        if line.strip() != "":
            solution.append(line) 
    return solution
    
if __name__ == '__main__':
    node_list, edge_list = read_sol(sys.stdin)
    for line in _comments:
        print('c ', line)
    print('t ', _graph_name)
    for n in node_list:
        print('n ', n[0], n[1], n[2])
    for e in edge_list:
        print('e ', e[0], e[1])

#  [Last modified: 2020 05 15 at 18:17:36 GMT]
